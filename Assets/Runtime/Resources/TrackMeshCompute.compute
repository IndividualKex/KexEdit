#pragma kernel VisualizationKernel
#pragma kernel DuplicationKernel
#pragma kernel ExtrusionKernel
#pragma kernel ExtrusionGizmoKernel
#pragma kernel StartCapKernel
#pragma kernel EndCapKernel

struct Point {
    float3 Position;
    float3 Direction;
    float3 Normal;
    float Distance;
    float Heart;
    float Time;
    float VisualizationValue;
};

StructuredBuffer<Point> _Points;
float _Count;

StructuredBuffer<int2> _SegmentBoundaries;
float _SegmentCount;

StructuredBuffer<float> _SegmentSelections;

RWStructuredBuffer<float4> _VisualizationData;
float _Selected;

RWStructuredBuffer<float4x4> _Matrices;
RWStructuredBuffer<uint> _DuplicationVisualizationIndices;
RWStructuredBuffer<uint> _CapVisualizationIndices;
float _Step;
float _Offset;

StructuredBuffer<float3> _CrossSectionVertices;
StructuredBuffer<float3> _CrossSectionNormals;
StructuredBuffer<uint> _CrossSectionTriangulation;
RWStructuredBuffer<float3> _ExtrusionVertices;
RWStructuredBuffer<float3> _ExtrusionNormals;
RWStructuredBuffer<uint> _ExtrusionIndices;
RWStructuredBuffer<uint> _ExtrusionVisualizationIndices;
float _CrossSectionVerticesLength;
float _CrossSectionTriangulationLength;

RWStructuredBuffer<float3> _ExtrusionGizmoVertices;
float _ExtrusionGizmoHeart;

float4x4 LookRotationMatrix(float3 forward, float3 up) {
    forward = normalize(forward);
    float3 right = normalize(cross(up, forward));
    up = normalize(cross(forward, right));
    
    float4x4 result = float4x4(
        float4(right.x, up.x, forward.x, 0),
        float4(right.y, up.y, forward.y, 0),
        float4(right.z, up.z, forward.z, 0),
        float4(0, 0, 0, 1)
    );
    
    return result;
}

float4x4 TRS(float3 pos, float4x4 rot) {
    float4x4 result = rot;
    result._m03_m13_m23 = pos;
    return result;
}

bool IsAtSegmentEnd(uint idx) {
    uint segmentCount = (uint)_SegmentCount;
    for (uint i = 0; i < segmentCount; i++) {
        if (idx == (uint)_SegmentBoundaries[i].y) {
            return true;
        }
    }
    return false;
}

bool IsAtSegmentStart(uint idx) {
    uint segmentCount = (uint)_SegmentCount;
    for (uint i = 0; i < segmentCount; i++) {
        if (idx == (uint)_SegmentBoundaries[i].x) {
            return true;
        }
    }
    return false;
}

uint GetSegmentIndex(uint idx) {
    uint segmentCount = (uint)_SegmentCount;
    for (uint i = 0; i < segmentCount; i++) {
        uint segmentStart = (uint)_SegmentBoundaries[i].x;
        uint segmentEnd = (uint)_SegmentBoundaries[i].y;
        if (idx >= segmentStart && idx <= segmentEnd) {
            return i;
        }
    }
    return 0;
}

[numthreads(64, 1, 1)]
void VisualizationKernel(uint3 id : SV_DispatchThreadID) {
    uint idx = id.x;
    uint count = (uint)_Count;
    if (idx >= count) return;

    Point p = _Points[idx];

    uint segmentIndex = GetSegmentIndex(idx);
    float segmentSelection = _SegmentSelections[segmentIndex];

    _VisualizationData[idx] = float4(p.VisualizationValue, 0, 0, segmentSelection);
}

[numthreads(64, 1, 1)]
void DuplicationKernel(uint3 id : SV_DispatchThreadID) {
    uint idx = id.x;
    uint count = (uint)_Count;
    if (idx >= count || IsAtSegmentEnd(idx)) return;

    Point p = _Points[idx];

    float4x4 rotation = LookRotationMatrix(p.Direction, p.Normal);
    float4x4 trs = TRS(p.Position, rotation);

    uint segmentCount = (uint)_SegmentCount;
    uint matrixIndex = 0;
    uint localIdx = idx;
    bool foundSegment = false;
    
    for (uint i = 0; i < segmentCount; i++) {
        uint segmentStart = (uint)_SegmentBoundaries[i].x;
        uint segmentEnd = (uint)_SegmentBoundaries[i].y;
        
        if (idx >= segmentStart && idx <= segmentEnd) {
            localIdx = idx - segmentStart;
            foundSegment = true;
            break;
        }
        
        uint segmentLength = segmentEnd - segmentStart + 1;
        uint effectiveLength = segmentLength - 1;
        uint segmentMatrices = (uint)_Offset < effectiveLength
            ? ((effectiveLength - 1 - (uint)_Offset) / (uint)_Step) + 1
            : 0;
        matrixIndex += segmentMatrices;
    }
    
    if (!foundSegment || (localIdx % (uint)_Step) != (uint)_Offset) return;
    
    matrixIndex += (uint)((localIdx - (uint)_Offset) / (uint)_Step);
    _Matrices[matrixIndex] = trs;
    _DuplicationVisualizationIndices[matrixIndex] = idx;
}

[numthreads(64, 1, 1)]
void ExtrusionKernel(uint3 id : SV_DispatchThreadID) {
    uint idx = id.x;
    uint count = (uint)_Count;
    if (idx >= count) return;

    Point p = _Points[idx];

    float4x4 rotation = LookRotationMatrix(p.Direction, p.Normal);
    float4x4 trs = TRS(p.Position, rotation);

    uint N = (uint)_CrossSectionVerticesLength / 2;
    uint M = (uint)_CrossSectionTriangulationLength;

    uint vertexOffset = idx * N;
    uint indexOffset = idx * M;

    for (uint i = 0; i < N; i++) {
        float3 crossPos = _CrossSectionVertices[i];
        float3 crossNormal = _CrossSectionNormals[i];

        float3 pos = mul(trs, float4(crossPos, 1)).xyz;
        float3 normal = mul(trs, float4(crossNormal, 0)).xyz;

        _ExtrusionVertices[vertexOffset + i] = pos;
        _ExtrusionNormals[vertexOffset + i] = normal;
        _ExtrusionVisualizationIndices[vertexOffset + i] = idx;
    }

    bool isValid = length(p.Direction) > 0.001 && length(p.Normal) > 0.001;
    bool isAtEnd = IsAtSegmentEnd(idx);
    if (isValid && idx < count - 1 && !isAtEnd) {
        for (uint j = 0; j < M; j++) {
            uint index = _CrossSectionTriangulation[j];
            _ExtrusionIndices[indexOffset + j] = index + vertexOffset;
        }
    }
    else {
        for (uint j = 0; j < M; j++) {
            _ExtrusionIndices[indexOffset + j] = 0;
        }
    }
}

[numthreads(64, 1, 1)]
void ExtrusionGizmoKernel(uint3 id : SV_DispatchThreadID) {
    uint idx = id.x;
    uint count = (uint)_Count;
    if (idx >= count) return;
    
    Point p = _Points[idx];
    float3 pos = p.Position + p.Normal * (p.Heart - _ExtrusionGizmoHeart);
    
    _ExtrusionGizmoVertices[idx * 2] = pos;
    
    if (!IsAtSegmentEnd(idx) && idx < count - 1) {
        Point nextP = _Points[idx + 1];
        float3 nextPos = nextP.Position + nextP.Normal * (nextP.Heart - _ExtrusionGizmoHeart);
        _ExtrusionGizmoVertices[idx * 2 + 1] = nextPos;
    } else {
        _ExtrusionGizmoVertices[idx * 2 + 1] = pos;
    }
}

[numthreads(64, 1, 1)]
void StartCapKernel(uint3 id : SV_DispatchThreadID) {
    uint segmentIdx = id.x;
    uint segmentCount = (uint)_SegmentCount;
    if (segmentIdx >= segmentCount) return;
    
    uint startIdx = (uint)_SegmentBoundaries[segmentIdx].x;
    Point p = _Points[startIdx];
    
    float4x4 rotation = LookRotationMatrix(p.Direction, p.Normal);
    float4x4 trs = TRS(p.Position, rotation);
    
    _Matrices[segmentIdx] = trs;
    _CapVisualizationIndices[segmentIdx] = startIdx;
}

[numthreads(64, 1, 1)]
void EndCapKernel(uint3 id : SV_DispatchThreadID) {
    uint segmentIdx = id.x;
    uint segmentCount = (uint)_SegmentCount;
    if (segmentIdx >= segmentCount) return;
    
    uint endIdx = (uint)_SegmentBoundaries[segmentIdx].y;
    Point p = _Points[endIdx];
    
    float4x4 rotation = LookRotationMatrix(p.Direction, p.Normal);
    float4x4 trs = TRS(p.Position, rotation);
    
    _Matrices[segmentIdx] = trs;
    _CapVisualizationIndices[segmentIdx] = endIdx;
}
